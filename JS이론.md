# 자바스크립트의 동작원리
> 알아보기 전에 https://ingg.dev/js-work/ 블로그에서 주제에 관해 많은 공부가 되었다. 꼭 다시 읽어보자
![](https://ingg.dev/213a51586e94904c5075045d2c94273b/work22.svg)

- Memory Heap : 메모리의 할당이 일어나는 곳
- Call Stack : 코드실행에 따라 호출스택이 쌓이는 곳 (실행 대기하는곳(?))

자바스크립트는 하나의 호출스택을 사용하여 호출스택에 쌓여있는 작업들을 차례차례 실행한다. 먼저 `main()` 함수는 처음 실행시 전역 컨텍스트이다. 즉 함수가 호출될때 생성되는 환경이다. 이것이 실행완료되면 콜스택이 비워지고 순서대로 코드가 실행된다.

### 자바스크립트 런타임
자바스크립트 엔진 밖에서도 자바스크립트에 관여하는 요소들이 있다. `Wep API, Task Queue, Event Loop`등이다. 런타임은 특정 언어로 만든 프로그램들을 실행할 수 있는 환경이다. Node.js나 크롬등의 브라우저들은 자바스크립트가 구동되는 환경이기 때문에, 이를 자바스크립트 런타임이라고 한다.

- Web API : Web API는 브라우저에서 제공되는 API이다. 자바스크립트 엔진에서 정의되지 않았던 setTimeout이나 HTTP 요청(ajax) 메소드, DOM 이벤트 등의 메소드를 지원한다.
- Task Queue : 이벤트 발생 후 호출되어야 할 콜백 함수들이 기다리는 공간. 이벤트 루프가 정한 순서대로 줄을 서 있으므로 콜백 큐(Callback Queue) 라고도 한다.
- Event Loop : 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정한다.

특히 비동기로 호출되는 함수들은 콜스택에 쌓이지 않고 태스크 큐로 보내진다

### 비동기적 처리
비동기적 처리란 특정 코드가 종료되지 않았어도 대기하지 않고 다음 코드를 실행하는 자바스크립트의 특성이다
```
console.log("시작"); 1번

setTimeout(function(){ 2번
    console.log("3초후 실행");
}, 3000);

console.log("끝"); 3번

// 시작
// 끝
// 3초후 실행
```
본래는 1~3번의 순서로 콜스택에 쌓여서 실행이 되어야겠지만, 콜스택에서 2번을 받고 `setTimeout`함수를 자바스크립트엔진이 처리하지 않고 `Wep API`가 처리를 하므로 콜백함수를 그쪽으로 전달한다. 그리고 바로 3번이 실행이 되고 `main()`함수가 리턴되며 콜스택에서 사라진다.
`Wep API`가 콜백함수 작업을 실행하는데 3초 후 `Task Queue`로 보낸다. `Event Loop`는 콜스택이 비어있으면 `Task Queue`에서 함수를 하나씩 꺼내 콜스택에 넣고 실행한다.

### 비동기처리가 필요한 이유
화면에서 서버로 데이터를 요청시 서버가 해당 요청에 대한 응답을 언제 할지 모르는 상태에서 다른 코드를 실행하지 않고 기다릴 수 는 없기 때문이다.

# 유사배열
>https://www.zerocho.com/category/JavaScript/post/5af6f9e707d77a001bb579d2  
>참고할 제로초 블로그

```
var array = [1, 2, 3];
var nodes = document.querySelectorAll('div'); // NodeList [div, div, div, div, div, ...]
var els = document.body.children; // HTMLCollection [noscript, link, div, script, ...]
```
코드에 나온 변수들 array, nodes, els 모두 대괄호로 감싸져있다. 겉으로만 봐서는 모두 배열인듯 보이지만 isArray 메소드를 사용해서 배열여부를 확인하면 nodes 와 els는 배열로 나오지 않는다.
```
var 유사배열 = {
  0: 'a',
  1: 'b',
  2: 'c',
};
```
위와같은 오브젝트형 변수도 유사배열이고 length도 찍을 수 있다. 배열처럼 유사배열[1] 도 찍을 수 있다. 이렇게 일반 배열처럼 사용가능해 보이는데 왜 배열과 유사배열을 구분해야할까?
#### 메소드 사용 가능여부
유사배열은 프로토타입의 여부에 따라 조금씩 다르지만 기본적으로 배열에 관련된 메소드 즉, 내장함수를 사용할 수가 없다. 간단히 말해서 배열이 아니기 때문에 당연히 사용할 수 없는것이다. 
그렇다면 영원히 메소드를 사용하지 못하는 것일까? `That's no no` 메소드를 빌려쓰는 방법이 존재하는데 call, apply와 같은 메소드를 사용하거나 Array.from()으로 배열을 만들어 사용할 수 있다. 아래의 강의를 확인해 보자
>https://www.zerocho.com/category/JavaScript/post/57433645a48729787807c3fd


# 옵셔널 체이닝
자바스크립트 공식문서 등 여러 곳에서는 옵셔널 체이닝에 대해 아래와 같이 표현하고 있다.
>옵셔널 체이닝 `?.` 을 사용하면 프로퍼티가 없는 중첩 객체를 에러 없이 안전하게 접근할 수 있습니다.

이게 무슨 소리인가 싶어서 나만의 언어로 재해석을 시도해 보았다.
```
const country = {
	city : {
    	Seoul : 'good',
        Busan : 'nice'
    }
}
console.log(country.coffee.hello)
```
오브젝트로 구성된 변수 `country` 에는 city라는 프로퍼티는 존재하지만 그 외의 프로퍼티는 존재하지 않는다. city 안에 Seoul과 Busan은 존재하지만 그 외에 것은 존재하지 않는다. 만약 여기에다가 위와 콘솔을 찍는 다면 어떻게 될까? 당연하게도 Type에 대한 오류가 발생할 것이다. 물론 지금과 같은 경우는 너무나 뻔한 경우이지만, 실제 코드를 작성하다보면 실수로 적혀진 오브젝트 등 여러가지 상황이 생길 것이다. 그때마다 오류가 떠서 실행이 지속적으로 중지가 된다면 그 문제를 찾기 위해서 시간을 오래 소모하게 될 것이다.

그러한 상황을 예방하고 에러를 방지하기 위해서 옵셔널 체이닝이라는 것을 활용하고 `?.` 라는 기호를 사용하여 뽑아내면 에러가 나지 않으면서 `undefined`로 출력이 되어 코드가 지속적으로 실행된다.

`console.log(country?.coffee?.hello)` 와 같이 콘솔을 찍게되면 `undefined`로 콘솔이 찍히며 에러가 나지 않고 다른 코드들이 지속적으로 실행된다는 의미이다.

### 다른 예시 
```
let user1 = {
  admin() {
    console.log("관리자 계정입니다.");
  }
}

let user2 = {};

user1.admin?.(); // 관리자 계정입니다.
user2.admin?.(); 
```
`user2.admin()` 에 `?.`이 없었다면 에러가 뜨면서 중지가 되었을 것이다. 하지만 해당 기호를 사용함으로 에러를 건너뛰고 코드가 진행된다.
